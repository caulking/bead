/**
 * jsPsych 8.x Batch Experiment
 * Generated by bead deployment system
 *
 * Experiment: Verb Argument Structure
 * Description: 
 */

// Global variables
let distributor = null;

/**
 * Main experiment entry point.
 * Loads data, assigns list, and runs experiment.
 */
async function runExperiment() {
    try {
        // Load distribution config
        const distConfig = await fetch('data/distribution.json').then(r => r.json());

        // Load lists from JSONL
        const lists = await loadLists('data/lists.jsonl');

        // Load items from JSONL
        const items = await loadItems('data/items.jsonl');

        // Initialize list distributor
        distributor = new ListDistributor(distConfig, lists);

        // Assign list to this participant
        const listIndex = await distributor.initialize();
        const assignedList = distributor.getAssignedList();

        console.log(`Assigned to list: ${assignedList.name} (index: ${listIndex})`);

        // Initialize jsPsych
        const jsPsych = initJsPsych({
            
            on_trial_start: jatos.addAbortButton,
            
            on_finish: async function() {
                // Mark as completed in batch session
                if (distributor) {
                    await distributor.markCompleted();
                }

                
                // Submit data and end study
                const resultData = jsPsych.data.get().json();
                
                jatos.submitResultData(resultData)
                    .then(() => jatos.endStudy(true))
                    .catch((error) => {
                        console.error("Failed to submit data:", error);
                        jatos.endStudy(false);
                    });
                
                
            },
            show_progress_bar: true,
            auto_update_progress_bar: true
        });

        
        // Add JATOS metadata
        jsPsych.data.addProperties({
            experiment_title: "Verb Argument Structure",
            participant_id: jatos.urlQueryParameters.PROLIFIC_PID || jatos.workerId,
            prolific_pid: jatos.urlQueryParameters.PROLIFIC_PID || null,
            prolific_study_id: jatos.urlQueryParameters.STUDY_ID || null,
            prolific_session_id: jatos.urlQueryParameters.SESSION_ID || null,
            jatos_worker_id: jatos.workerId,
            jatos_study_result_id: jatos.studyResultId,
            jatos_component_result_id: jatos.componentResultId,
            assigned_list_index: listIndex,
            assigned_list_name: assignedList.name,
            assigned_list_id: assignedList.id,
            experiment_start_time: new Date().toISOString(),
        });
        

        // Build timeline
        const timeline = [];

        // Instructions
        
        timeline.push({
            type: jsPsychHtmlKeyboardResponse,
            stimulus: `
                <div class="instructions">
                    <h2>Instructions</h2>
                    <p>Choose the more natural sentence.</p>
                    <p><em>Press any key to continue</em></p>
                </div>
            `,
            data: {
                trial_type: 'instructions'
            }
        });
        

        // Get items for assigned list
        const listItemIds = assignedList.item_refs;
        if (!listItemIds || listItemIds.length === 0) {
            throw new Error(
                `Assigned list '${assignedList.name}' has no items. ` +
                `Check that lists were created with items before generate().`
            );
        }

        // Look up items by UUID
        const listItems = listItemIds.map(itemId => {
            const item = items[itemId];
            if (!item) {
                throw new Error(
                    `Item ${itemId} referenced in list '${assignedList.name}' not found in items.jsonl. ` +
                    `Verify all items were serialized correctly.`
                );
            }
            return item;
        });

        // Create trials from items
        // TODO: This needs to call the trial creation logic
        // For now, assume items have rendered_elements that we can display
        for (const item of listItems) {
            timeline.push({
                type: jsPsychHtmlButtonResponse,
                stimulus: item.rendered_elements.text || 'No text',
                choices: item.rendered_elements.choices || ['Option A', 'Option B'],
                data: {
                    trial_type: 'experimental_trial',
                    item_id: item.id,
                    item_metadata: item.item_metadata
                }
            });
        }

        // Completion
        timeline.push({
            type: jsPsychHtmlKeyboardResponse,
            stimulus: `
                <div class="completion">
                    <h2>âœ“ Complete</h2>
                    <p>Thank you for participating!</p>
                    <p>Your responses have been recorded.</p>
                    
                    <p><em>You may close this window.</em></p>
                    
                </div>
            `,
            choices: "NO_KEYS",
            trial_duration: null,
            data: {
                trial_type: 'completion'
            }
        });

        // Run experiment
        await jsPsych.run(timeline);

    } catch (error) {
        console.error('Experiment error:', error);
        document.body.innerHTML = `
            <div style="max-width: 600px; margin: 100px auto; padding: 20px; border: 2px solid #d00; background: #fee;">
                <h2>Experiment Error</h2>
                <p><strong>Error:</strong> ${error.message}</p>
                <p>Please contact the experiment administrator.</p>
                <pre style="background: #fff; padding: 10px; overflow: auto;">${error.stack}</pre>
            </div>
        `;
    }
}


// Wait for JATOS to load
jatos.onLoad(() => {
    runExperiment();
});
